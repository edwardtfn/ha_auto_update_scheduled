####################################################################################################
#####                        Home Assistant Auto-update on Schedule                            #####
#####             Repository: https://github.com/edwardtfn/ha_auto_update_scheduled            #####
####################################################################################################
##### Purpose: YAML blueprint to automatically update Home Assistant and its components when   #####
#####          updates are available, following a schedule and with configurable options.      #####
####################################################################################################
##### Author: edwardtfn - https://github.com/edwardtfn - https://buymeacoffee.com/edwardfirmo  #####
####################################################################################################
##### NOTE:                                                                                    #####
##### - Home Assistant may restart automatically as part of the update process.                #####
##### - Use under your own risk! Please review Home Assistant community discussions about      #####
#####   the risks involved in auto-updating the system.                                        #####
##### - For discussions:                                                                       #####
#####     https://community.home-assistant.io/t/459281                                         #####
##### - For support and bug reports:                                                           #####
#####     https://github.com/edwardtfn/ha_auto_update_scheduled/issues                         #####
####################################################################################################
---
blueprint:
  name: Home Assistant Auto-update on a schedule base
  author: Edward Firmo (https://github.com/edwardtfn)
  homeassistant:
    min_version: '2024.8.0'
  description: >
    # Home Assistant Auto-update

    Update Home Assistant automatically when a new update is available.

    v2025.1.0

    Attention:

    * Home Assistant may restart automatically as part of the update process.

    * **Use under your own risk!** Please see the discussions on Home Assistant community around the risks involved on auto-updating the system.

    For questions and suggestions, please use
    [this thread in Home Assistant Community portal](https://community.home-assistant.io/t/scheduled-auto-update-for-home-assistant/459281).
  domain: automation
  source_url: https://raw.githubusercontent.com/edwardtfn/ha_auto_update_scheduled/main/auto_update_scheduled.yaml
  input:
    when_section:
      name: When (Schedule, etc.)
      icon: mdi:calendar
      description: Select when the updates should happen and when it should be skipped.
      collapsed: false
      input:
        schedule_entity:
          name: Schedule entity
          description: >
            You can create a [Schedule](https://www.home-assistant.io/integrations/schedule) under
            [Settings > Devices & Services > Helpers](https://my.home-assistant.io/redirect/config_flow_start/?domain=schedule).

            Note => The schedule windows will define when an update will start.
            It is possible that a backup, an update or a restart process finishes after the schedule window,
            but new updates won't stars outside the schedule windows.
          default: []
          selector:
            entity:
              multiple: false
              domain: schedule

        schedule_monthday_earliest:
          name: Earliest day in the month to run the update process
          description: >
            Usually a new major version of Home Assistant is available on the begining of every month.
            Some people consider those releases as not stable enough and prefer to avoid those versions,
            not updating the system until the mid of the month (day 15).

            Notes:
              - If you select a day higher than 28 the updates won't run every month.
              - Selecting `0` will disable the check.
          default: 0
          selector:
            number:
              min: 1
              max: 31
              step: 1
              mode: slider

        schedule_monthday_last:
          name: Latest day in the month to run the update process
          description: >
            Specify the latest day in month, on which this update can run.

            Note:
              - Selecting `0` or a date lower than the "Earliest Day" will disable the check.
          default: 0
          selector:
            number:
              min: 0
              max: 31
              step: 1
              mode: slider

        update_out_of_schedule:
          name: Out of schedule entities (optional)
          description:
            You can select update entities which will be updated as soon an update is detected,
            even if outside the schedule windows.
          default: []
          selector:
            entity:
              multiple: true
              domain:
                - update

        pause_entities:
          name: Pause update entities (optional)
          description: >
            You can select one or more entities to pause the updates.
            If any of the selected entities is "On" or "True" the system won't be updated on the schedule time.

            You can use this to hold your updates when you have a party at home,
            or when you are on vacations and don't want to be concerned about updates on Home Assistant.
          default: []
          selector:
            entity:
              multiple: true
              domain:
                - input_boolean
                - binary_sensor
                - switch

    what_section:
      name: What (optional)
      icon: mdi:update
      description: Select what should be updated and what shouldn't be updated.
      collapsed: true
      input:
        core_os_update_mode:
          name: Update mode for Home Assistant core and OS updates
          description: >
            Please select the update mode for Home Assistant core and Home Assistan OS updates.

            * All: All updates will be installed.

            * Patches only:
              ✅ From 2022.11.0 to 2022.11.3 will be updated (patches).
              ❌ From 2022.11.x to 2022.12.x will be ignored (minor update).
              ❌ From 2022.12.x to 2023.1.x will be ignored (major update).
            * Don't update: Ignore any update.

          default: "all"
          selector: &update_mode-selector
            select:
              multiple: false
              options:
                - label: All
                  value: "all"
                - label: Patches only
                  value: "patches"
                - label: Don't update
                  value: "ignore"

        firmware_update_mode:
          name: Update mode for device's firmware
          description: >
            Please select the update mode for firmware in the devices connected to Home Assistant (when supported as an HA update).

            * All: All updates will be installed.

            * Patches only:
              ✅ From 2022.11.0 to 2022.11.3 will be updated (patches).
              ❌ From 2022.11.x to 2022.12.x will be ignored (minor update).
              ❌ From 2022.12.x to 2023.1.x will be ignored (major update).
            * Don't update: Ignore any update.

          default: "all"
          selector: *update_mode-selector

        general_update_mode:
          name: Update mode for general updates
          description: >
            Please select the update mode for everything that is not a device's firmware or a core component of Home Assistant.

            This includes add-ons, HACS componentes, custom cards, etc.

            * All: All updates will be installed.

            * Patches only:
              ✅ From 2022.11.0 to 2022.11.3 will be updated (patches).
              ❌ From 2022.11.x to 2022.12.x will be ignored (minor update).
              ❌ From 2022.12.x to 2023.1.x will be ignored (major update).
            * Don't update: Ignore any update.

          default: "all"
          selector: *update_mode-selector

        update_inclusion_mode:
          name: Entity Inclusion Mode
          description: >-
            Please select the entity inclusion mode.
            * All:
              Just build the update entity list from all available update.* entities, which are in state 'on'.
            * Specified/Specified-Single:
              Build the update entity list from the specified entity list, filtering for entities in 'on' state.
              - Specified: Updates all matching entities
              - Specified-Single: Updates only the first matching entity
            * Searchfilter:
              This works as a wildcard filter.
              Examples:
                'update.zigbee2mqtt_'   => all update entities from zigbee2mqtt addon
                'update.esphome_'       => all update entities from esphome devices if their names start with 'esphome_'
            * Searchfilter-Single:
              Just like the searchfilter, but only the first entity. (Sorted alphabetically)
          default: "all"
          selector:
            select:
              multiple: false
              options:
                - label: All
                  value: "all"
                - label: Specified
                  value: "specified"
                - label: Specified-Single
                  value: "specified-single"
                - label: Searchfilter
                  value: "searchfilter"
                - label: Searchfilter-Single
                  value: "searchfilter-single"

        update_inclusion_entity_list:
          name: Entity Inclusion List
          description: >-
            => Important: This entity list will only be used when the Update Inclusion mode is set to "Specified" or "Specified-Single".
            Select the items which should be updated.
          default: []
          selector:
            entity:
              multiple: true
              domain: update

        update_inclusion_entity_searchfilter:
          name: Entity Inclusion Searchfilter
          description: >-
            => Important: This searchfilter will only be used when the Update Inclusion mode is set to "Searchstring".
            This defines the Searchfilter for finding the right update entities.
            This enables wildcard-like searching for a group of entities, aka "all zigbee entities" or "everything from Sonoff" etc.
          default: ""
          selector:
            text:
              multiline: false

        update_exclusions:
          name: Exclusions (optional)
          description: 'Select the items that should NOT be included on the automated updates.


            => Use this if you want to keep some add-on on an specific version and avoid auto-updates to it.'
          default: []
          selector:
            entity:
              multiple: true
              domain: update

    backup_section:
      name: Backup (optional)
      icon: mdi:backup-restore
      description: Select the back-up options
      collapsed: true
      input:
        backup_bool:
          name: Create a full backup before start the updates?
          default: true
          selector:
            boolean:

        backup_timeout:
          name: Backup Timeout
          description: >-
            Specify how much time the automation waits for the backup process.
            We can't check wether the backup was successful.
            Per default we wait 1 hour to finish the backup.
          default: 60
          selector:
            number:
              mode: box
              min: 1
              max: 600
              unit_of_measurement: minutes

        max_backup_age:
          name: Maximum backup age (or zero, to disable) (optional)
          description:
            This requires the [Google Drive Backup](https://github.com/sabeechen/hassio-google-drive-backup)
            addon to be installed and configured to automatically backup, and provide
            a sensor with the backup states. The setting only checks for the age of
            the automatic backups from that addon, not the backups created internally
            by this blueprint.
          default:
            days: 0
            hours: 0
            minutes: 0
            seconds: 0
          selector:
            duration:
              enable_day: true

        backup_location:
          name: Backup Location
          description: >-
            You can create a new backup location under [Settings > System > Storage](https://my.home-assistant.io/redirect/storage/).

            Specify where to store the backup for this autoupdate process.
          default: "/backup"
          selector:
            backup_location:

    actions_section:
      name: Actions (optional)
      icon: mdi:shoe-print
      description: Select actions to run at diferent moments on the update process
      collapsed: true
      input:
        actions_pre_update:
          name: Pre-update actions (optional)
          description: 'Actions to execute before the backup or any update starts.

            You can use this to send notifications, turn on/off devices or activate scenes before starting the updates.


            Note => Please be aware that all actions will run right before the update process, which can happens over-night. Take this in account when selecting your actions.

            Note => The variable "\{\{ updates_list \}\}" is available for your actions and contains the list of pending updates.'
          default: []
          selector:
            action: {}

        actions_pre_restart:
          name: Pre-restart actions (optional)
          description: 'Actions to execute before the automation requests a restart.

            You can use this to send notifications, turn on/off devices or stopping automations before restarting Home Assistant.


            Note => Please be aware that all actions will run right before the restart process, which can happens over-night. Take this in account when selecting your actions.

            Note => Note all the restarts will be controlled by this automation, like when a Core update is installed. These actions might not be executed in those cases.

            Note => The variable "\{\{ updates_list \}\}" is available for your actions and contains the list of pending updates.'
          default: []
          selector:
            action: {}

        actions_pos_update:
          name: Post-update actions (optional)
          description: >
            Actions to execute AFTER the update process finishes.

            You can use this to send notifications, turn on/off devices or activate scenes after applying  the updates.


            Note => Please be aware that all actions will run right after the update process, which can happens over-night.
            Take this in account when selecting your actions.

            Note => The variable "\{\{ updates_list \}\}" is available for your actions and contains the list of pending updates.

            **IMPORTANT** => Some updates will automatically restart Home Assistant, causing the automation to interrupt before finishing, preventing the pos-updates actions to be executed.
            If you have critical actions to run after an update, consider including also in another automation based on Home Assistant start.
          default: []
          selector:
            action: {}

    telegram_section:
      name: Telegram notifications (optional)
      icon: mdi:bell
      description: Here you can setup an optional notification to Telegram
      collapsed: true
      input:
        notification_telegram_enable:
          name: Enable telegram notifications
          default: false
          selector:
            boolean:

        notification_telegram_target_id:
          name: Number of Telegram Target (Chat or Group ID)
          description: >
            This specifies the Telegram Target (Chat or group ID) aka the target to send the message to.

            Example: -1111111111111
          default: ""
          selector:
            text:

        notification_telegram_disable_notification:
          name: Disable the Telegram notification from the Telegram client.
          description: >
            This switches to a 'silent' message without a notification on other devices with a running telegram client.
          default: false
          selector:
            boolean:

    general_settings:
      name: General settings (optional)
      icon: mdi:cog
      description: Select additional settings to the update process
      collapsed: true
      input:
        restart_type:
          name: Force Home Assistant to restart if required by any update?
          description: >
            This won't affect updates where a restart is automatic,
            but for updates requiring a manual restart (quite common on HACS)
            this blueprint can automatically force a restart by the end of the updates.
          default: "no-restart"
          selector:
            select:
              multiple: false
              options:
                - label: "Don't force a restart"
                  value: "no-restart"
                - label: "Restart Home Assistant core"
                  value: "core"
                - label: "Restart Home Assistant host"
                  value: "host"

        verbose_logging_bool:
          name: Log addon progress with verbosity to the logbook? (optional)
          default: false
          selector:
            boolean: {}

        update_process_started_entity:
          name: '"Update Process Started" Toggle Entity (optional)'
          description: >
            You can create a [Toggle Helper](https://www.home-assistant.io/integrations/input_boolean) under
            [Settings > Devices & Services > Helpers](https://my.home-assistant.io/redirect/config_flow_start/?domain=input_boolean).

            This entity will be used to determine if we still have to do a backup
            on automation start - so it is for inner workings of this automation.

            This saves you from getting multiple backups in the same update window.
          default: []
          selector:
            entity:
              multiple: false
              domain: input_boolean

        update_timeout:
          name: Update Timeout
          description: |
            Maximum time to wait for each update to complete.

            This protects the automation of waiting forever for an update that fails.

            Usually updates don't take that very long,
            so feel free to ajust this time to something that fits better your environment.

            The default is 600 seconds (10 minutes).
            You can select any value between 10 seconds and 7200 seconds (2 hours).

            If an update times out:
            - The automation will log an error message
            - The automation will continue with the next update
            - The timed-out update may still complete in the background
          default: 600
          selector:
            number:
              min: 10
              max: 7200
              step: 10
              unit_of_measurement: seconds
              mode: box

mode: single
max_exceeded: warning

trigger_variables:
  input_pause_entities: !input pause_entities
  input_update_exclusions: !input update_exclusions
  input_update_out_of_schedule: !input update_out_of_schedule
  schedule_monthday_earliest: !input schedule_monthday_earliest
  schedule_monthday_last: !input schedule_monthday_last
  input_schedule_monthday_earliest: '{{ schedule_monthday_earliest | int(0) }}'
  input_schedule_monthday_last: '{{ schedule_monthday_last | int(0) }}'
  input_update_inclusion_entity_list: !input update_inclusion_entity_list
  input_update_inclusion_entity_searchfilter: !input update_inclusion_entity_searchfilter
  input_update_process_started_entity: !input update_process_started_entity

trigger:
  - id: HA Schedule based
    platform: state
    entity_id: !input schedule_entity
  - id: HA Start
    platform: homeassistant
    event: start
  - id: New update
    platform: template
    value_template: >-
      {{
        states.update
        | default([])
        | selectattr("state", "eq", "on")
        | rejectattr("entity_id", "in", input_update_exclusions)
        | list | count | int(0) > 0
      }}
  - id: New day
    platform: template
    value_template: >
      {{
        (now().day >= input_schedule_monthday_earliest or input_schedule_monthday_earliest == 0) and
        (
          now().day <= input_schedule_monthday_last or
          input_schedule_monthday_last == 0 or
          input_schedule_monthday_last < input_schedule_monthday_earliest
        )
      }}
  - id: Automations reloaded
    platform: event
    event_type: automation_reloaded
  - id: Pause entities changed
    platform: state
    entity_id: !input pause_entities

condition:
  - condition: or
    conditions:
      - condition: template
        value_template: >-
          {{
            states.update
            | default([])
            | selectattr("state", "eq", "on")
            | rejectattr("entity_id", "in", input_update_exclusions)
            | list | count | int(0) > 0
          }}
      - condition: and
        conditions:
          - condition: trigger
            id: "HA Start"
          - '{{ input_update_process_started_entity | default([]) | count == 1 }}'
          - condition: state
            entity_id: !input update_process_started_entity
            state: "on"

  - condition: template
    value_template: >
      {{
        (now().day >= input_schedule_monthday_earliest or input_schedule_monthday_earliest == 0) and
        (now().day <= input_schedule_monthday_last or input_schedule_monthday_last == 0)
      }}

  - condition: or
    conditions:
      - "{{ input_pause_entities | default([]) | list | count | int(0) < 1 }}"
      - condition: state
        entity_id: !input pause_entities
        state: 'off'

variables:
  input_verbose_logging_bool: !input verbose_logging_bool
  input_core_os_update_mode: !input core_os_update_mode
  input_firmware_update_mode: !input firmware_update_mode
  input_general_update_mode: !input general_update_mode
  input_update_inclusion_mode: !input update_inclusion_mode
  input_notification_telegram_enable: !input notification_telegram_enable
  input_notification_telegram_target_id: !input notification_telegram_target_id
  input_notification_telegram_disable_notification: !input notification_telegram_disable_notification
  core_update_entity: >
    {% for u in integration_entities('hassio') | select('search', '^update[.]')
      if (device_attr(u, 'identifiers') | first)[1] == 'core' %}
        {{ u }}
    {% endfor %}
  os_update_entity: >
    {% for u in integration_entities('hassio') | select('search', '^update[.]')
      if (device_attr(u, 'identifiers') | first)[1] == 'OS' %}
        {{ u }}
    {% endfor %}
  supervisor_update_entity: >
    {% for u in integration_entities('hassio') | select('search', '^update[.]')
      if (device_attr(u, 'identifiers') | first)[1] == 'supervisor' %}
        {{ u }}
    {% endfor %}
  is_continuing_from_a_restart: >
    {{
      input_update_process_started_entity | default([]) | count == 1 and
      is_state(input_update_process_started_entity | first, "on")
    }}
  friendly_name: |
    {% set friendly_name_tmp = state_attr(this.entity_id, "friendly_name") | default("") %}
    {{
      friendly_name_tmp
      if friendly_name_tmp is string and friendly_name_tmp | length > 0
      else "Auto-update"
    }}

action:
  - &recalc_update_list
    variables:
      firmware_update_entities: >
        {{
          states.update
          | default([])
          | selectattr("state", "eq", "on")
          | selectattr('attributes.device_class', 'defined')
          | selectattr('attributes.device_class', 'eq', 'firmware')
          | rejectattr('entity_id', 'in', input_update_exclusions)
          | map(attribute='entity_id')
          | list
        }}
      general_update_entities: >
        {% if input_update_inclusion_mode == "all" %}
          {{
            states.update
            | default([])
            | selectattr('state', 'eq', 'on')
            | rejectattr('entity_id', 'in', core_update_entity)
            | rejectattr('entity_id', 'in', os_update_entity)
            | rejectattr('entity_id', 'in', supervisor_update_entity)
            | rejectattr('entity_id', 'in', firmware_update_entities)
            | rejectattr('entity_id', 'in', input_update_exclusions)
            | map(attribute='entity_id')
            | list
          }}
        {% elif input_update_inclusion_mode == "specified" %}
          {{
            states.update
            | default([])
            | selectattr('state', 'eq', 'on')
            | selectattr('entity_id', 'in', input_update_inclusion_entity_list)
            | rejectattr('entity_id', 'in', core_update_entity)
            | rejectattr('entity_id', 'in', os_update_entity)
            | rejectattr('entity_id', 'in', supervisor_update_entity)
            | rejectattr('entity_id', 'in', firmware_update_entities)
            | rejectattr('entity_id', 'in', input_update_exclusions)
            | map(attribute='entity_id')
            | list
          }}
        {% elif input_update_inclusion_mode == "specified-single" %}
          {{
            states.update
            | default([])
            | selectattr('state', 'eq', 'on')
            | selectattr('entity_id', 'in', input_update_inclusion_entity_list)
            | rejectattr('entity_id', 'in', core_update_entity)
            | rejectattr('entity_id', 'in', os_update_entity)
            | rejectattr('entity_id', 'in', supervisor_update_entity)
            | rejectattr('entity_id', 'in', firmware_update_entities)
            | rejectattr('entity_id', 'in', input_update_exclusions)
            | map(attribute='entity_id')
            | list
            | first
          }}
        {% elif input_update_inclusion_mode == "searchstring" %}
          {{
            states.update
            | default([])
            | selectattr('state', 'eq', 'on')
            | selectattr('entity_id', 'match', input_update_inclusion_entity_searchfilter)
            | rejectattr('entity_id', 'in', core_update_entity)
            | rejectattr('entity_id', 'in', os_update_entity)
            | rejectattr('entity_id', 'in', supervisor_update_entity)
            | rejectattr('entity_id', 'in', firmware_update_entities)
            | rejectattr('entity_id', 'in', input_update_exclusions)
            | map(attribute='entity_id')
            | list
          }}
        {% elif input_update_inclusion_mode == "searchfilter-single" %}
          {{
            states.update
            | default([])
            | selectattr('state', 'eq', 'on')
            | selectattr('entity_id', 'match', input_update_inclusion_entity_searchfilter)
            | rejectattr('entity_id', 'in', core_update_entity)
            | rejectattr('entity_id', 'in', os_update_entity)
            | rejectattr('entity_id', 'in', supervisor_update_entity)
            | rejectattr('entity_id', 'in', firmware_update_entities)
            | rejectattr('entity_id', 'in', input_update_exclusions)
            | map(attribute='entity_id')
            | list
            | first
          }}
        {% endif %}
      combined_list: |
        {{
          (
            firmware_update_entities | default([]) | list
            if firmware_update_entities is sequence
            else [firmware_update_entities | string] if firmware_update_entities is not none else []
          ) +
          (
            general_update_entities | default([]) | list
            if general_update_entities is sequence
            else [general_update_entities | string] if general_update_entities is not none else []
          ) +
          (
            core_update_entity | default([]) | list
            if core_update_entity is sequence
            else [core_update_entity | string] if core_update_entity is not none else []
          ) +
          (
            os_update_entity | default([]) | list
            if os_update_entity is sequence
            else [os_update_entity | string] if os_update_entity is not none else []
          ) +
          (
            supervisor_update_entity | default([]) | list
            if supervisor_update_entity is sequence
            else [supervisor_update_entity | string] if supervisor_update_entity is not none else []
          )
        }}
      pending_update_list: |
        {{
          states.update
          | default([])
          | selectattr("state", "eq", "on")
          | selectattr('entity_id', 'in', combined_list)
          | rejectattr('entity_id', 'in', input_update_exclusions)
          | map(attribute='entity_id')
          | list
        }}
      pending_update_count: '{{ pending_update_list | list | count | int(0) }}'

  - variables:
      update_list: '{{ pending_update_list }}'
      updates_list: '{{ pending_update_list }}'
      is_there_anything_to_update: '{{ pending_update_count > 0 }}'

  - alias: Preparation  # Inform logbook and telegram which update automation is running
    sequence:
      - variables:
          log_message: '{{ friendly_name }} is {{ "re" if is_continuing_from_a_restart else ""}}starting'
      - &logbook_update
        if: "{{ input_verbose_logging_bool }}"
        then:
          - alias: Logbook - Update
            action: logbook.log
            data:
              name: Auto-update
              entity_id: '{{ this.entity_id }}'
              message: '{{ log_message }}'
            continue_on_error: true
        continue_on_error: true
      - &send_telegram_message
        alias: Send telegram message
        if:
          - condition: template
            value_template: '{{ input_notification_telegram_enable }}'
            alias: Check if telegram notifications are enabled
        then:
          - alias: Telegram bot - Send message
            action: telegram_bot.send_message
            data:
              title: '{{ friendly_name }}'
              target: "{{ input_notification_telegram_target_id }}"
              disable_notification: '{{ input_notification_telegram_disable_notification }}'
              message: '{{ log_message }}'

  - alias: Report list of updates
    if: '{{ is_there_anything_to_update }}'
    then:
      - variables:
          log_message: >
            List of updates:
              - {{ states.update
                | selectattr('state', 'eq', 'on')
                | rejectattr('entity_id', 'in', input_update_exclusions)
                | map(attribute='name') | list | join('

              - ') }}
      - *logbook_update
      - *send_telegram_message
    else:
      - variables:
          log_message: "There's nothing to update"
      - *logbook_update
      - *send_telegram_message

  - alias: Set ON helper flag
    if:
      - '{{ input_update_process_started_entity | default([]) | count > 0 }}'
      - '{{ input_update_process_started_entity[0] | string | length > 0 }}'
    then:
      - action: input_boolean.turn_on
        target:
          entity_id: !input update_process_started_entity

  - alias: Pre-update actions
    if: '{{ is_there_anything_to_update and not is_continuing_from_a_restart }}'
    then:
      - *recalc_update_list
      - variables:
          log_message: "Running pre-update actions..."
      - *logbook_update

      - alias: "Run pre-update actions"
        continue_on_error: true
        sequence: !input actions_pre_update

  - alias: Backup
    if: '{{ is_there_anything_to_update and not is_continuing_from_a_restart }}'
    then:
      - *recalc_update_list
      - variables:
          input_backup_bool: !input backup_bool
          input_backup_timeout_minutes: !input backup_timeout
          input_backup_timeout: '{{ input_backup_timeout_minutes | int(60) }}'
          temp_max_backup_age: !input max_backup_age
          input_max_backup_age_seconds: >
            {{
              timedelta(
                days=temp_max_backup_age.days,
                hours=temp_max_backup_age.hours,
                minutes=temp_max_backup_age.minutes,
                seconds=temp_max_backup_age.seconds
              ).total_seconds()
            }}
      - alias: Check existing backups uploaded
        continue_on_error: true
        if:
          - '{{ not is_state("sensor.backup_state", "unknown") }}'
          - '{{ not is_state("sensor.backup_state", "unavailable") }}'
          - '{{ input_max_backup_age_seconds > 0 }}'
        then:
          - variables:
              last_backup_timestamp_list: >
                {{
                  states.sensor
                  | selectattr("attributes.last_backup", "defined")
                  | map(attribute="attributes.last_backup")
                  | list
                }}
              last_backup_timestamp: '{{ last_backup_timestamp_list | max if last_backup_timestamp_list | count > 0 else None }}'
          - alias: Check if backup state is defined
            if: '{{ last_backup_timestamp != None }}'
            then:
              - stop: "Backup State sensor not found"
          - alias: Check age of last uploaded backup
            if: >-
              {{ as_timestamp(now()) - as_timestamp(last_backup_timestamp) > input_max_backup_age_seconds }}
            then:
              - stop: "Last uploaded backup is too old"
      - alias: "Backup"
        continue_on_error: true
        if:
          - '{{ input_backup_bool }}'
          - condition: state
            entity_id: !input update_process_started_entity
            state: 'off'
        then:
          - action: input_boolean.turn_on
            target:
              entity_id: "{{ input_update_process_started_entity }}"
            continue_on_error: true
          - variables:
              log_message: "Backing up Home Assistant"
          - *logbook_update
          - *send_telegram_message

          - alias: "Call backup service"
            action: hassio.backup_full
            data:
              compressed: true
            continue_on_error: true

          - variables:
              log_message: >
                Backup triggered

                Waiting {{ input_backup_timeout | int(60) }} minutes
          - *logbook_update
          - *send_telegram_message

          - alias: "Wait for the backup"  # There's no sensor for when the backup finishes
            delay:
              minutes: "{{ input_backup_timeout | int(60) }}"

          - variables:
              log_message: >
                Backup Wait time finished.

                Continuing...
          - *logbook_update
          - *send_telegram_message
        else: []

  - alias: Update generic
    if: '{{ is_there_anything_to_update }}'
    then:
      - *recalc_update_list
      - variables:
          log_message: "Update generic items"
      - *logbook_update
      - alias: "Update - Generic"
        continue_on_error: true
        repeat:
          while:
            - "{{ input_general_update_mode in ['patches', 'major_and_minor', 'all'] }}"
            - condition: state
              entity_id: !input schedule_entity
              state: "on"
            - condition: template
              value_template: >
                {{ ( states.update
                  | selectattr('state', 'eq', 'on')
                  | selectattr('entity_id', 'in', pending_update_list)
                  | rejectattr('entity_id', 'in', core_update_entity)
                  | rejectattr('entity_id', 'in', os_update_entity)
                  | rejectattr('entity_id', 'in', firmware_update_entities)
                  | rejectattr('entity_id', 'in', input_update_exclusions)
                  | map(attribute='entity_id')
                  | list | count | int(0) ) > 0
                }}
          sequence:
            - variables:
                log_message: "Starting sequence of standard updates..."
            - *logbook_update
            - variables:
                pending_update_list: >
                  {{ states.update
                    | selectattr('state', 'eq', 'on')
                    | selectattr('entity_id', 'in', pending_update_list)
                    | rejectattr('entity_id', 'in', core_update_entity)
                    | rejectattr('entity_id', 'in', os_update_entity)
                    | rejectattr('entity_id', 'in', firmware_update_entities)
                    | rejectattr('entity_id', 'in', input_update_exclusions)
                    | map(attribute='entity_id')
                    | list
                    }}

            - &log_updating
              alias: Log updating
              sequence:
                - variables:
                    log_message: "Updating `{{pending_update_list[0]}}`..."
                - *logbook_update
                - *send_telegram_message

            - &update_install
              alias: "Update - Install"
              continue_on_error: true
              action: update.install
              data: {}
              target:
                entity_id: '{{ pending_update_list[0] }}'

            - &update_wait
              alias: "Update - Wait"
              sequence:
                - alias: Wait
                  continue_on_error: true
                  wait_template: "{{ is_state(pending_update_list[0], 'off') }}"
                  continue_on_timeout: true
                  timeout: !input update_timeout
                - if: '{{ wait.completed }}'
                  then:
                    - variables:
                        log_message: '`{{ pending_update_list[0] }}` updated successfuly'
                    - *logbook_update
                    - *send_telegram_message
                  else:
                    - variables:
                        log_message: 'ERROR: `{{ pending_update_list[0] }}` update timed out'
                    - *logbook_update
                    - *send_telegram_message

  - alias: Devices firmware
    if: '{{ is_there_anything_to_update }}'
    then:
      - *recalc_update_list
      - variables:
          log_message: "Device's firmware"
      - *logbook_update

      - alias: "Update - Devices firmware"
        continue_on_error: true
        repeat:
          while:
            - "{{ input_firmware_update_mode in ['patches', 'major_and_minor', 'all'] }}"
            - condition: state
              entity_id: !input schedule_entity
              state: "on"
            - condition: template
              value_template: >
                {{ ( states.update
                  | selectattr('state', 'eq', 'on')
                  | selectattr('entity_id', 'in', pending_update_list)
                  | rejectattr('entity_id', 'in', core_update_entity)
                  | rejectattr('entity_id', 'in', os_update_entity)
                  | selectattr('entity_id', 'in', firmware_update_entities)
                  | rejectattr('entity_id', 'in', input_update_exclusions)
                  | map(attribute='entity_id')
                  | list | count | int(0) ) > 0
                }}
          sequence:
            - variables:
                log_message: "Starting sequence of Devices firmware update"
            - *logbook_update
            - *send_telegram_message

            - variables:
                pending_update_list: >
                  {{ states.update
                    | selectattr('state', 'eq', 'on')
                    | selectattr('entity_id', 'in', pending_update_list)
                    | rejectattr('entity_id', 'in', core_update_entity)
                    | rejectattr('entity_id', 'in', os_update_entity)
                    | selectattr('entity_id', 'in', firmware_update_entities)
                    | map(attribute='entity_id')
                    | list
                  }}

            - *log_updating
            - *update_install
            - *update_wait

  - alias: Update core
    if: '{{ is_there_anything_to_update }}'
    then:
      - *recalc_update_list
      - variables:
          log_message: "Update Core"
      - *logbook_update
      - alias: "Update - Core"
        continue_on_error: true
        repeat:
          while:
            - "{{ input_core_os_update_mode in ['patches', 'major_and_minor', 'all'] }}"
            - condition: state
              entity_id: !input schedule_entity
              state: "on"
            - condition: template
              value_template: >
                {{ ( states.update
                  | selectattr('state', 'eq', 'on')
                  | selectattr('entity_id', 'in', pending_update_list)
                  | selectattr('entity_id', 'in', core_update_entity)
                  | rejectattr('entity_id', 'in', os_update_entity)
                  | rejectattr('entity_id', 'in', firmware_update_entities)
                  | rejectattr('entity_id', 'in', input_update_exclusions)
                  | map(attribute='entity_id')
                  | list | count | int(0) ) > 0
                }}
          sequence:
            - variables:
                log_message: "Starting sequence of core items updates..."
            - *logbook_update
            - *send_telegram_message

            - variables:
                pending_update_list: >
                  {{ states.update
                    | selectattr('state', 'eq', 'on')
                    | selectattr('entity_id', 'in', pending_update_list)
                    | selectattr('entity_id', 'in', core_update_entity)
                    | rejectattr('entity_id', 'in', os_update_entity)
                    | rejectattr('entity_id', 'in', firmware_update_entities)
                    | rejectattr('entity_id', 'in', input_update_exclusions)
                    | map(attribute='entity_id')
                    | list
                  }}

            - *log_updating
            - *update_install
            - *update_wait

  - alias: Update OS
    if: '{{ is_there_anything_to_update }}'
    then:
      - *recalc_update_list
      - variables:
          log_message: "Update OS"
      - *logbook_update
      - alias: "Update - OS"
        continue_on_error: true
        repeat:
          while:
            - "{{ input_core_os_update_mode in ['patches', 'major_and_minor', 'all'] }}"
            - condition: state
              entity_id: !input schedule_entity
              state: "on"
            - condition: template
              value_template: >
                {{ ( states.update
                  | selectattr('state', 'eq', 'on')
                  | selectattr('entity_id', 'in', pending_update_list)
                  | rejectattr('entity_id', 'in', core_update_entity)
                  | selectattr('entity_id', 'in', os_update_entity)
                  | rejectattr('entity_id', 'in', firmware_update_entities)
                  | rejectattr('entity_id', 'in', input_update_exclusions)
                  | map(attribute='entity_id')
                  | list | count | int(0) ) > 0
                }}
          sequence:
            - variables:
                log_message: "Starting sequence of OS update"
            - *logbook_update
            - *send_telegram_message

            - variables:
                pending_update_list: >
                  {{ states.update
                    | selectattr('state', 'eq', 'on')
                    | selectattr('entity_id', 'in', pending_update_list)
                    | rejectattr('entity_id', 'in', core_update_entity)
                    | selectattr('entity_id', 'in', os_update_entity)
                    | rejectattr('entity_id', 'in', firmware_update_entities)
                    | rejectattr('entity_id', 'in', input_update_exclusions)
                    | map(attribute='entity_id')
                    | list
                  }}

            - *log_updating
            - *update_install
            - *update_wait

  - alias: Update - Remaining  # Update all remaining items => this chaches up if some update item was left behind
    continue_on_error: true
    if:
      - '{{ is_there_anything_to_update }}'
      - condition: state
        entity_id: !input schedule_entity
        state: "on"
    then:
      - *recalc_update_list
      - variables:
          log_message: "Updating all remaining items (if any)"
      - *logbook_update
      - *send_telegram_message

      - alias: "Update - Remaining - Install"
        continue_on_error: true
        service: update.install
        data: {}
        target:
          entity_id: >-
            {{ states.update
            | selectattr('state', 'eq', 'on')
            | selectattr('entity_id', 'in', pending_update_list)
            | rejectattr('entity_id', 'in', input_update_exclusions)
            | map(attribute='entity_id')
            | list
            }}
      - alias: "Update - Remaining - Wait"
        continue_on_error: true
        wait_template: >-
          {{
            (
              states.update
              | selectattr('state', 'eq', 'on')
              | selectattr('entity_id', 'in', pending_update_list)
              | rejectattr('entity_id', 'in', input_update_exclusions)
              | list
              | count
              | int(0)
            ) < 1
          }}
        continue_on_timeout: true
        timeout: !input update_timeout

  - alias: Finishing
    sequence:
      - *recalc_update_list
      - variables:
          log_message: "Finishing update process"
      - *logbook_update
      - *send_telegram_message

      - variables:
          log_message: >
            Remaining updates:
            {{ '- ' + states.update
              | selectattr('state', 'eq', 'on')
              | selectattr('entity_id', 'in', pending_update_list)
              | rejectattr('entity_id', 'in', input_update_exclusions)
              | map(attribute='name') | list | join('

            - ') if
              states.update
              | selectattr('state', 'eq', 'on')
              | selectattr('entity_id', 'in', pending_update_list)
              | rejectattr('entity_id', 'in', input_update_exclusions)
              | map(attribute='name') | list | count | int(0) > 0
              else 'None remaining'
            }}
      - *logbook_update
      - *send_telegram_message

  - alias: Restart  # Restart Home Assistant
    sequence:
      - variables:
          input_restart_type: !input restart_type
          log_message: >
            {{ states.update
              | selectattr('attributes.release_summary', 'defined')
              | selectattr('attributes.release_summary', 'search', "<ha-alert alert-type='error'>")
              | map(attribute='entity_id')
              | list
              | count
              | int(0)
            }} item(s) pending a restart:
            - {{ states.update
                | selectattr('attributes.release_summary', 'defined')
                | selectattr('attributes.release_summary', 'search', "<ha-alert alert-type='error'>")
                | map(attribute='entity_id')
                | list
                | join('
                - ')
              }}
      - *logbook_update
      - *send_telegram_message

      - alias: "Restart"
        continue_on_error: true
        sequence:
          - condition: '{{ input_restart_type != "no-restart" }}'
          - alias: Wait pending operations  # Wait for any pending operations to complete
            delay:
              seconds: 30
          - condition: |
              {{
                ( states.update
                  | selectattr('attributes.release_summary', 'defined')
                  | selectattr('attributes.release_summary', 'search', "<ha-alert alert-type='error'>")
                  | map(attribute='entity_id')
                  | list | count | int(0)
                ) > 0
              }}
          - alias: "Restart - Check config"
            continue_on_error: true
            action: homeassistant.check_config
          - variables:
              has_invalid_config: >
                {{
                  states.persistent_notification.invalid_config.state
                  | default('unavailable') == 'notifying'
                }}
              has_check_config_notification: >
                {{
                  states.persistent_notification.homeassistant_check_config.state
                  | default('unavailable') == 'notifying'
                }}
          - if: '{{ has_invalid_config or has_check_config_notification }}'
            then:
              - variables:
                  log_message: "Running pre-restart actions..."
              - *logbook_update
              - *send_telegram_message

              - alias: "Run pre-restart actions"
                continue_on_error: true
                sequence: !input actions_pre_restart
              - variables:
                  log_message: >
                    Skipping restart process due to notifications of invalid configurations:

                      - has_invalid_config = {{ has_invalid_config }}

                      - has_check_config_notification = {{ has_check_config_notification }}
              - *logbook_update
              - *send_telegram_message
            else:
              - variables:
                  log_message: >
                    Restart was asked by admin.

                    Restarting Home Assistant ({{ input_restart_type }})
              - *logbook_update
              - *send_telegram_message

              - alias: "Wait 15 seconds to deliver the telegram message."
                delay:
                  seconds: 15

              - alias: "Restart - Call reboot service"
                continue_on_error: true
                action: '{{ "hassio.host_reboot" if input_restart_type == "host" else "homeassistant.restart" }}'

  - alias: Post-update actions
    sequence:
      - variables:
          log_message: "Running post-update actions"
      - *logbook_update
      - *send_telegram_message

      - alias: "Run post-update actions"
        continue_on_error: true
        sequence: !input actions_pos_update

  - alias: Set OFF helper flag
    if:
      - '{{ input_update_process_started_entity | default([]) | count > 0 }}'
      - '{{ input_update_process_started_entity[0] | string | length > 0 }}'
    then:
      - action: input_boolean.turn_off
        target:
          entity_id: !input update_process_started_entity

  - alias: Done  # All done!
    sequence:
      - variables:
          log_message: "Done!"
      - *logbook_update
      - *send_telegram_message
...
