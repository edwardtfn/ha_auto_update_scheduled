blueprint:
  name: Home Assistant Auto-update on a schedule base
  author: Edward Firmo (https://github.com/edwardtfn)
  homeassistant:
    min_version: '2024.8.0'
  description: >
    # Home Assistant Auto-update

    Update Home Assistant automatically when a new update is available.

    v2025.1.0

    Attention:

    * Home Assistant may restart automatically as part of the update process.

    * **Use under your own risk!** Please see the discussions on Home Assistant community around the risks involved on auto-updating the system.

    For questions and suggestions, please use
    [this thread in Home Assistant Community portal](https://community.home-assistant.io/t/scheduled-auto-update-for-home-assistant/459281).
  domain: automation
  source_url: https://raw.githubusercontent.com/edwardtfn/ha_auto_update_scheduled/main/auto_update_scheduled.yaml
  input:
    when_section:
      name: When (Schedule, etc.)
      icon: mdi:calendar
      description: Select when the updates should happen and when it should be skipped.
      collapsed: false
      input:
        schedule_entity:
          name: Schedule entity
          description: >
            You can create a [Schedule](https://www.home-assistant.io/integrations/schedule) under
            [Settings > Devices & Services > Helpers](https://my.home-assistant.io/redirect/config_flow_start/?domain=schedule).

            Note => The schedule windows will define when an update will start.
            It is possible that a backup, an update or a restart process finishes after the schedule window,
            but new updates won't stars outside the schedule windows.
          default: []
          selector:
            entity:
              multiple: false
              domain: schedule

        schedule_monthday_earliest:
          name: Earliest day in the month to run the update process
          description: >
            Usually a new major version of Home Assistant is available on the begining of every month.
            Some people consider those releases as not stable enough and prefer to avoid those versions,
            not updating the system until the mid of the month (day 15).

            Note => If you select a day higher than 28 the updates won't run every month.
          default: 1
          selector:
            number:
              min: 1
              max: 31
              step: 1
              mode: slider

        schedule_monthday_last:
          name: Latest day in the month to run the update process
          description: 'Specify the latest day in month, on which this update can run.
            Note => If you select a day lower than the Earliest Day in month then the update will never run.'
          default: 1
          selector:
            number:
              min: 1
              max: 31
              step: 1
              mode: slider

        update_out_of_schedule:
          name: Out of schedule entities (optional)
          description:
            You can select update entities which will be updated as soon an update is detected,
            even if outside the schedule windows.
          default: []
          selector:
            entity:
              multiple: true
              domain:
                - update

        pause_entities:
          name: Pause update entities (optional)
          description: >
            You can select one or more entities to pause the updates.
            If any of the selected entities is "On" or "True" the system won't be updated on the schedule time.

            You can use this to hold your updates when you have a party at home,
            or when you are on vacations and don't want to be concerned about updates on Home Assistant.
          default: []
          selector:
            entity:
              multiple: true
              domain:
                - input_boolean
                - binary_sensor
                - switch

    what_section:
      name: What (optional)
      icon: mdi:update
      description: Select what should be updated and what shouldn't be updated.
      collapsed: true
      input:
        core_os_update_mode:
          name: Update mode for Home Assistant core and OS updates
          description: >
            Please select the update mode for Home Assistant core and Home Assistan OS updates.

            * All: All updates will be installed.

            * Patches only:
              ✅ From 2022.11.0 to 2022.11.3 will be updated (patches).
              ❌ From 2022.11.x to 2022.12.x will be ignored (minor update).
              ❌ From 2022.12.x to 2023.1.x will be ignored (major update).
            * Don't update: Ignore any update.

          default: "all"
          selector: &update_mode-selector
            select:
              multiple: false
              options:
                - label: All
                  value: "all"
                - label: Patches only
                  value: "patches"
                - label: Don't update
                  value: "ignore"

        firmware_update_mode:
          name: Update mode for device's firmware
          description: >
            Please select the update mode for firmware in the devices connected to Home Assistant (when supported as an HA update).

            * All: All updates will be installed.

            * Patches only:
              ✅ From 2022.11.0 to 2022.11.3 will be updated (patches).
              ❌ From 2022.11.x to 2022.12.x will be ignored (minor update).
              ❌ From 2022.12.x to 2023.1.x will be ignored (major update).
            * Don't update: Ignore any update.

          default: "all"
          selector: *update_mode-selector

        general_update_mode:
          name: Update mode for general updates
          description: >
            Please select the update mode for everything that is not a device's firmware or a core component of Home Assistant.

            This includes add-ons, HACS componentes, custom cards, etc.

            * All: All updates will be installed.

            * Patches only:
              ✅ From 2022.11.0 to 2022.11.3 will be updated (patches).
              ❌ From 2022.11.x to 2022.12.x will be ignored (minor update).
              ❌ From 2022.12.x to 2023.1.x will be ignored (major update).
            * Don't update: Ignore any update.

          default: "all"
          selector: *update_mode-selector

        update_inclusion_mode:
          name: Entity Inclusion Mode
          description: >-
            Please select the entity inclusion mode.
            * All: 
              Just build the update entity list from all available update.* entities, which are in state 'on'.
            * Specified: 
              Just build the update entity list from the specified entity list. Will also filter on the entities in 'on' state.
            * Specified-Single: 
              Same as specified, but will only update the first entity from the list.
            * Searchfilter:
              This works as a wildcard filter.
              Examples:
                'update.zigbee2mqtt_'   => all update entities from zigbee2mqtt addon
                'update.esphome_'       => all update entities from esphome devices if their names start with 'esphome_'
            * Searchfilter-Single:
              Just like the searchfilter, but only the first entity. (Sorted alphabetically)
          selector:
            select:
              multiple: false
              options:
                - label: All
                  value: "all"
                - label: Specified
                  value: "specified"
                - label: Specified-Single
                  value: "specified-single"
                - label: Searchfilter
                  value: "searchfilter"
                - label: Searchfilter-Single
                  value: "searchfilter-single"

        update_inclusion_entity_list:
          name: Entity Inclusion List
          description: >-
            => Important: This entity list will only be used when the Update Inclusion mode is set to "Specified" or "Specified-Single".
            Select the items which should be updated.
          default: [ ]
          selector:
            entity:
              multiple: true
              domain: update

        update_inclusion_entity_searchfilter:
          name: Entity Inclusion Searchfilter
          description: >-
            => Important: This searchfilter will only be used when the Update Inclusion mode is set to "Searchstring".
            This defines the Searchfilter for finding the right update entities.
            This enables wildcard-like searching for a group of entities, aka "all zigbee entities" or "everything from Sonoff" etc.
          default: ""
          selector:
            text:
              multiline: false

        update_exclusions:
          name: Exclusions (optional)
          description: 'Select the items that should NOT be included on the automated updates.


            => Use this if you want to keep some add-on on an specific version and avoid auto-updates to it.'
          default: []
          selector:
            entity:
              multiple: true
              domain: update

    backup_section:
      name: Backup (optional)
      icon: mdi:backup-restore
      description: Select the back-up options
      collapsed: true
      input:
        backup_bool:
          name: Create a full backup before start the updates?
          default: true
          selector:
            boolean:

        backup_timeout:
          name: Backup Timeout
          description: >-
            Specify how much time the automation waits for the backup process.
            We can't check wether the backup was successful.
            Per default we wait 1 hour to finish the backup.
          default: 60
          selector:
            number:
              mode: box
              min: 1
              max: 600
              unit_of_measurement: minutes

        backup_location:
          name: Backup Location
          description: >-
            You can create a new backup location under [Settings > System > Storage](https://my.home-assistant.io/redirect/storage/).

            Specify where to store the backup for this autoupdate process.
          default: "/backup"
          selector:
            backup_location:

    actions_section:
      name: Actions (optional)
      icon: mdi:shoe-print
      description: Select actions to run at diferent moments on the update process
      collapsed: true
      input:
        actions_pre_update:
          name: Pre-update actions (optional)
          description: 'Actions to execute before the backup or any update starts.

            You can use this to send notifications, turn on/off devices or activate scenes before starting the updates.


            Note => Please be aware that all actions will run right before the update process, which can happens over-night. Take this in account when selecting your actions.

            Note => The variable "\{\{ updates_list \}\}" is available for your actions and contains the list of pending updates.'
          default: []
          selector:
            action: {}

        actions_pre_restart:
          name: Pre-restart actions (optional)
          description: 'Actions to execute before the automation requests a restart.

            You can use this to send notifications, turn on/off devices or stopping automations before restarting Home Assistant.


            Note => Please be aware that all actions will run right before the restart process, which can happens over-night. Take this in account when selecting your actions.

            Note => Note all the restarts will be controlled by this automation, like when a Core update is installed. These actions might not be executed in those cases.

            Note => The variable "\{\{ updates_list \}\}" is available for your actions and contains the list of pending updates.'
          default: []
          selector:
            action: {}

        actions_pos_update:
          name: Post-update actions (optional)
          description: >
            Actions to execute AFTER the update process finishes.

            You can use this to send notifications, turn on/off devices or activate scenes after applying  the updates.


            Note => Please be aware that all actions will run right after the update process, which can happens over-night.
            Take this in account when selecting your actions.

            Note => The variable "\{\{ updates_list \}\}" is available for your actions and contains the list of pending updates.

            **IMPORTANT** => Some updates will automatically restart Home Assistant, causing the automation to interrupt before finishing, preventing the pos-updates actions to be executed.
            If you have critical actions to run after an update, consider including also in another automation based on Home Assistant start.
          default: []
          selector:
            action: {}

    telegram_section:
      name: Telegram notifications (optional)
      icon: mdi:bell
      description: Here you can setup an optional notification to Telegram
      collapsed: true
      input:
        notification_telegram_enable:
          name: Enable telegram notifications
          default: false
          selector:
            boolean:

        notification_telegram_target_id:
          name: Number of Telegram Target (Chat or Group ID)
          description: >
            This specifies the Telegram Target (Chat or group ID) aka the target to send the message to.

            Example: -1111111111111
          default: ""
          selector:
            text:

        notification_telegram_disable_notification:
          name: Disable the Telegram notification from the Telegram client.
          description: This switches to a 'silent' message without a notification on other devices with a running telegram client.
          default: false
          selector:
            boolean:

    general_settings:
      name: General settings (optional)
      icon: mdi:cog
      description: Select additional settings to the update process
      collapsed: true
      input:
        restart_type:
          name: Force Home Assistant to restart if required by any update?
          description: This won't affect updates where a restart is automatic, but for updates requiring a manual restart (quite common on HACS) this blueprint can automatically force a restart by the end of the updates.
          default: "no-restart"
          selector:
            select:
              multiple: false
              options:
                - label: "Don't force a restart"
                  value: "no-restart"
                - label: "Restart Home Assistant core"
                  value: "core"
                - label: "Restart Home Assistant host"
                  value: "host"
        verbose_logging_bool:
          name: Log addon progress with verbosity to the logbook? (optional)
          default: false
          selector:
            boolean: {}
        update_process_started_entity:
          name: '"Update Process Started" Toggle Entity'
          description: >
            You can create a [Toggle Helper](https://www.home-assistant.io/integrations/input_boolean) under
            [Settings > Devices & Services > Helpers](https://my.home-assistant.io/redirect/config_flow_start/?domain=input_boolean).

            This entity will be used to determine if we still have to do a backup on automation start - so it is for inner workings of this automation.

            This saves you from getting multiple backups in the same update window.
          selector:
            entity:
              multiple: false
              domain: input_boolean

mode: single
max_exceeded: warning

trigger_variables:
  input_update_exclusions: !input update_exclusions
  input_update_out_of_schedule: !input update_out_of_schedule
  updates_available: >
    {% set updates_available_obj =
        states.update
        | default([])
        | selectattr("state", "eq", "on")
        | rejectattr("entity_id", "in", input_update_exclusions)
    %}
    {{
      updates_available_obj | map(attributes="entity_id") | list
      if (updates_available_obj | list | count | int(0) > 0)
      else []
    }}
  input_schedule_monthday_earliest: !input schedule_monthday_earliest
  input_schedule_monthday_last: !input schedule_monthday_last
  input_update_inclusion_mode: !input update_inclusion_mode
  input_update_inclusion_entity_list: !input update_inclusion_entity_list
  input_update_inclusion_entity_searchfilter: !input update_inclusion_entity_searchfilter
  input_notification_telegram_enable: !input notification_telegram_enable
  input_notification_telegram_target_id: !input notification_telegram_target_id
  input_notification_telegram_disable_notification: !input notification_telegram_disable_notification

  updates_list: &refresh_updates_list >
    {% if input_update_inclusion_mode == "all" %}
      {{ states.update | default([]) | selectattr('state','eq','on') | rejectattr('entity_id', 'in', input_update_exclusions) | map(attribute='entity_id') | list }}
    {% elif input_update_inclusion_mode == "specified" %}
      {{ input_update_inclusion_entity_list | default([]) | selectattr('state','eq','on') | rejectattr('entity_id', 'in', input_update_exclusions) | map(attribute='entity_id') | list }}
    {% elif input_update_inclusion_mode == "specified" %}
      {{ input_update_inclusion_entity_list | default([]) | selectattr('state','eq','on') | rejectattr('entity_id', 'in', input_update_exclusions) | map(attribute='entity_id') | list | first }}
    {% elif input_update_inclusion_mode == "searchstring" %}
      {{ states.update | default([]) | selectattr('state','eq','on') | rejectattr('entity_id', 'in', input_update_exclusions) | selectattr('entity_id', 'match', input_update_inclusion_entity_searchfilter) | map(attribute='entity_id') | sort | list }}
    {% elif input_update_inclusion_mode == "searchfilter-single" %}
      {{ states.update | default([]) | selectattr('state','eq','on') | rejectattr('entity_id', 'in', input_update_exclusions) | selectattr('entity_id', 'match', input_update_inclusion_entity_searchfilter) | map(attribute='entity_id') | sort | first }}
    {% endif %}

trigger:
  - id: HA Schedule based
    platform: state
    entity_id: !input schedule_entity
  - id: HA Start
    platform: homeassistant
    event: start
  - id: New update
    platform: template
    value_template: >-
      {{
        states.update
        | default([])
        | selectattr("state", "eq", "on")
        | rejectattr("entity_id", "in", input_update_exclusions)
        | list | count | int(0) > 0
      }}
  - id: New day
    platform: template
    value_template: >
      {{
        now().day >= (input_schedule_monthday_earliest | int(0)) and
        now().day <= (input_schedule_monthday_last     | int(0))
      }}
  - id: Automations reloaded
    platform: event
    event_type: automation_reloaded
  - id: Pause entities changed
    platform: state
    entity_id: !input pause_entities

condition:
  # this cant be a condition for the whole automation because we have to "run" the automation to disable the input_boolean helper at the end of one complete update process
  #- condition: template
  #  value_template: >-
  #    {{
  #      states.update
  #      | default([])
  #      | selectattr("state", "eq", "on")
  #      | rejectattr("entity_id", "in", input_update_exclusions)
  #      | list | count | int(0) > 0
  #    }}

  - condition: template
    value_template: >
      {{
        now().day >= (input_schedule_monthday_earliest | int(0)) and
        now().day <= (input_schedule_monthday_last     | int(0))
      }}

  - condition: or
    conditions:
      - "{{ input_pause_entities | default([]) | list | count | int(0) < 1 }}"
      - condition: state
        entity_id: !input pause_entities
        state: 'off'

variables:
  input_pause_entities: !input pause_entities
  temp_input_update_exclusions: !input update_exclusions
  input_verbose_logging_bool: !input verbose_logging_bool
  input_backup_bool: !input backup_bool
  input_backup_timeout_minutes: !input backup_timeout
  input_backup_timeout: '{{ input_backup_timeout_minutes | int(60) }}'
  input_restart_type: !input restart_type
  input_core_os_update_mode: !input core_os_update_mode
  input_firmware_update_mode: !input firmware_update_mode
  input_general_update_mode: !input general_update_mode
  updates_list: *refresh_updates_list
  pending_updates_list: []

action:
  ######### Inform logbook and telegram which update automation is running #########
  - alias: If Telegram notifications are enabled send telegram message to specified target.
    if:
      - condition: template
        value_template: "{{ true if input_notification_telegram_enable is true else false }}"
        alias: Check if telegram notifications are enabled
    then:
      - data:
          message: '{{ this.entity_id }} is starting now.'
          target: "{{ input_notification_telegram_target_id }}"
          disable_notification: "{{ true if input_notification_telegram_disable_notification is true else false }}"
        alias: Telegram Houseofnerds Message to group chat
        action: telegram_bot.send_message
  - alias: "Logbook"
    continue_on_error: true
    service: logbook.log
    data:
      name: Inform which update automation is running
      entity_id: '{{ this.entity_id }}'
      message: '{{ this.entity_id }} is starting now.'

  ########## Check for skipping core/OS ##########
  - alias: "Re-check conditions after restart"
    continue_on_error: true
    if:
      - >
        {{
          (
            states.update
            | selectattr('state','eq','on')
            | selectattr('entity_id', 'in', updates_list)
            | rejectattr('entity_id', 'in', input_update_exclusions)
            | list
            | count
            | int(0)
          ) < 1
        }}
      - condition: and
        conditions:
        - condition: trigger
          id: "HA Start"
        - condition: state
          entity_id: !input update_process_started_entity
          state: "on"
    then:
      - action: input_boolean.turn_off
        target:
          entity_id: "{{ input_update_process_started_entity }}"
      - alias: If Telegram notifications are enabled send telegram message to specified target.
        if:
          - condition: template
            value_template: "{{ true if input_notification_telegram_enable is true else false }}"
            alias: Check if telegram notifications are enabled
        then:
          - data:
              message: "We dont have any updates to work on. Exiting..."
              target: "{{ input_notification_telegram_target_id }}"
              disable_notification: "{{ true if input_notification_telegram_disable_notification is true else false }}"
            alias: Telegram Houseofnerds Message to group chat
            action: telegram_bot.send_message
      - stop: Nothing to update
    else: []
  - alias: "check conditions on first run"
    continue_on_error: true
    if:
      - >
        {{
          (
            states.update
            | selectattr('state','eq','on')
            | selectattr('entity_id', 'in', updates_list)
            | rejectattr('entity_id', 'in', input_update_exclusions)
            | list
            | count
            | int(0)
          ) < 1
        }}
      - condition: and
        conditions:
        - condition: not
          conditions:
          - condition: trigger
            id: "HA Start"
        - condition: state
          entity_id: !input update_process_started_entity
          state: "off"
    then:
      - action: input_boolean.turn_off
        target:
          entity_id: "{{ input_update_process_started_entity }}"
      - alias: If Telegram notifications are enabled send telegram message to specified target.
        if:
          - condition: template
            value_template: "{{ true if input_notification_telegram_enable is true else false }}"
            alias: Check if telegram notifications are enabled
        then:
          - data:
              message: "We seem to have installed all needed Updates. Disabling the 'Update Process Started' entity and stopping update process."
              target: "{{ input_notification_telegram_target_id }}"
              disable_notification: "{{ true if input_notification_telegram_disable_notification is true else false }}"
            alias: Telegram Houseofnerds Message to group chat
            action: telegram_bot.send_message
      - stop: Nothing to update
    else: []
  ########## Starting ##########
  - &logbook-variables
    if: "{{ input_verbose_logging_bool }}"
    then:
      - alias: Logbook - variables
        continue_on_error: true
        action: logbook.log
        data:
          name: Auto-update
          entity_id: '{{ this.entity_id }}'
          message: >-
            Variables:
              input_backup_bool: {{ input_backup_bool }},
              input_restart_type: {{ input_restart_type }},
              input_verbose_logging_bool: {{ input_verbose_logging_bool }},
              input_schedule_monthday_earliest: {{ input_schedule_monthday_earliest }},
              input_schedule_monthday_last: {{ input_schedule_monthday_last }},
              input_update_exclusions: {{ input_update_exclusions }},
              input_core_os_update_mode: {{ input_core_os_update_mode }},
              input_firmware_update_mode: {{ input_firmware_update_mode }},
              input_general_update_mode: {{ input_general_update_mode }},
              core_update_entity: {{ core_update_entity }},
              os_update_entity: {{ os_update_entity }},
              supervisor_update_entity: {{ supervisor_update_entity }},
              firmware_update_entities: {{ firmware_update_entities }},
              general_update_entities: {{ general_update_entities }},
              updates_list: {{ updates_list }}
    continue_on_error: true

  - if: "{{ input_verbose_logging_bool }}"
    then:
      - alias: "Logbook - A new update is available"
        action: logbook.log
        data:
          name: Auto-update
          entity_id: '{{ this.entity_id }}'
          domain: update
          message: A new update is available for Home Assistant.
      - alias: "Logbook - List of updates"
        continue_on_error: true
        action: logbook.log
        data:
          name: Auto-update
          entity_id: '{{ this.entity_id }}'
          domain: update
          message: >
            List of updates:
            - {{ states.update
              | selectattr('state','eq','on')
              | selectattr('entity_id', 'in', pending_updates_list)
              | rejectattr('entity_id', 'in', input_update_exclusions)
              | map(attribute='name') | list | join('

            - ') }}

      - alias: If Telegram notifications are enabled send telegram message to specified target.
        if:
          - condition: template
            value_template: "{{ true if input_notification_telegram_enable is true else false }}"
            alias: Check if telegram notifications are enabled
        then:
          - data:
              message: |
                List of updates:
                - {{ states.update 
                  | selectattr('state','eq','on') 
                  | selectattr('entity_id', 'in', updates_list)
                  | rejectattr('entity_id', 'in', input_update_exclusions)
                  | map(attribute='name') | list | join(' 
                - ') }}
              target: "{{ input_notification_telegram_target_id }}"
              disable_notification: "{{ true if input_notification_telegram_disable_notification is true else false }}"
            alias: Telegram Houseofnerds Message to group chat
            action: telegram_bot.send_message

      - alias: "Logbook: Running pre-update actions"
        continue_on_error: true
        action: logbook.log
        data:
          name: Auto-update
          entity_id: '{{ this.entity_id }}'
          message: Running pre-update actions...
    continue_on_error: true

  - alias: "Run pre-update actions"
    continue_on_error: true
    choose:
      - conditions:
          - '{{ true }}'
        sequence: !input actions_pre_update
    default: []

  ########## Backup ##########
  - alias: Check existing backups uploaded
    continue_on_error: true
    if:
      - "{{ input_max_backup_age_seconds > 0 }}"
    then:
      - variables:
          last_backup_timestamp_list: >
            {{
              states.sensor
              | selectattr("attributes.last_backup", "defined")
              | map(attribute="attributes.last_backup")
              | list
            }}
          last_backup_timestamp: '{{ last_backup_timestamp_list | max if last_backup_timestamp_list | count > 0 else None }}'
      - alias: Check if backup state is defined
        if: '{{ last_backup_timestamp != None }}'
        then:
          - stop: "Backup State sensor not found"
      - alias: Check age of last uploaded backup
        if: >-
          {{ as_timestamp(now()) - as_timestamp(last_backup_timestamp) > input_max_backup_age_seconds }}
        then:
          - stop: "Last uploaded backup is too old"
  - alias: "Backup"
    continue_on_error: true
    if:
      - "{{ input_backup_bool }}"
    then:
      - if: "{{ input_verbose_logging_bool }}"
        then:
          - alias: "Logbook - Backing up"
            continue_on_error: true
            action: logbook.log
            data:
              name: Auto-update
              entity_id: '{{ this.entity_id }}'
              message: Backing up Home Assistant.
      - alias: "Call backup service"
        continue_on_error: true
        action: hassio.backup_full
        data:
          compressed: true
      - if: "{{ input_verbose_logging_bool }}"
        then:
          - alias: "Backup triggered"
            continue_on_error: true
            action: logbook.log
            data:
              name: Auto-update
              entity_id: '{{ this.entity_id }}'
              message: Backup triggered
          - alias: If Telegram notifications are enabled send telegram message to specified target.
            if: '{{ input_notification_telegram_enable }}'
            then:
              - data:
                  message: "Backup is triggered - Waiting defined time: {{ input_backup_timeout | int(60) }} minutes"
                  target: "{{ input_notification_telegram_target_id }}"
                  disable_notification: "{{ true if input_notification_telegram_disable_notification is true else false }}"
                alias: Telegram Houseofnerds Message to group chat
                action: telegram_bot.send_message
          - alias: "Give x minutes for the backup" # There's no sensor for when the backup finishes
            delay:
              minutes: "{{ input_backup_timeout | int(60) }}"
          - alias: If Telegram notifications are enabled send telegram message to specified target.
            if: '{{ input_notification_telegram_enable }}'
            then:
              - data:
                  message: "Backup Waittime finished. Continuing..."
                  target: "{{ input_notification_telegram_target_id }}"
                  disable_notification: "{{ true if input_notification_telegram_disable_notification is true else false }}"
                alias: Telegram Houseofnerds Message to group chat
                action: telegram_bot.send_message
    else: []

  ########## Update add-ons (Standard) ##########
  - *recalc_update_list
  - *logbook-variables
  - alias: "Update - Standard"
    continue_on_error: true
    repeat:
      while:
        - "{{ input_general_update_mode in ['patches', 'major_and_minor', 'all'] }}"
        - condition: state
          entity_id: !input schedule_entity
          state: "on"
        - condition: template
          value_template: >
            {{ ( states.update
              | selectattr('state','eq','on')
              | selectattr('entity_id', 'in', pending_updates_list)
              | rejectattr('entity_id', 'in', core_update_entity)
              | rejectattr('entity_id', 'in', os_update_entity)
              | rejectattr('entity_id', 'in', firmware_update_entities)
              | rejectattr('entity_id', 'in', input_update_exclusions)
              | map(attribute='entity_id')
              | list | count | int(0) ) > 0
            }}
      sequence:
        - if: "{{ input_verbose_logging_bool }}"
          then:
            - alias: "Update - Standard - Logbook - Starting"
              continue_on_error: true
              action: logbook.log
              data:
                name: Auto-update
                entity_id: '{{ this.entity_id }}'
                message: "Starting sequence of standard updates..."
        - variables:
            pending_update_list: >
              {{ states.update
                | selectattr('state','eq','on')
                | selectattr('entity_id', 'in', pending_updates_list)
                | rejectattr('entity_id', 'in', core_update_entity)
                | rejectattr('entity_id', 'in', os_update_entity)
                | rejectattr('entity_id', 'in', firmware_update_entities)
                | rejectattr('entity_id', 'in', input_update_exclusions)
                | map(attribute='entity_id')
                | list
                }}
        - if: "{{ input_verbose_logging_bool }}"
          then:
            - alias: "Update - Standard - Logbook - Updating"
              continue_on_error: true
              action: logbook.log
              data:
                name: Auto-update
                entity_id: '{{ this.entity_id }}'
                message: "Updating {{pending_update_list[0]}} of {{pending_update_list}} ..."
        - alias: "Update - Standard - Install"
          continue_on_error: true
          action: update.install
          data: {}
          target:
            entity_id: '{{ pending_update_list[0] }}'
        - alias: "Update - Standard - Wait"
          continue_on_error: true
          wait_template: "{{ is_state(pending_update_list[0], 'off') }}"
          continue_on_timeout: true
          timeout: '3600'

  ########## Update core items ##########
  - *recalc_update_list
  - *logbook-variables
  - alias: "Update - Core"
    continue_on_error: true
    repeat:
      while:
        - "{{ input_core_os_update_mode in ['patches', 'major_and_minor', 'all'] }}"
        - condition: state
          entity_id: !input schedule_entity
          state: "on"
        - condition: template
          value_template: >
            {{ ( states.update
              | selectattr('state','eq','on')
              | selectattr('entity_id', 'in', pending_updates_list)
              | selectattr('entity_id', 'in', core_update_entity)
              | rejectattr('entity_id', 'in', os_update_entity)
              | rejectattr('entity_id', 'in', firmware_update_entities)
              | rejectattr('entity_id', 'in', input_update_exclusions)
              | map(attribute='entity_id')
              | list | count | int(0) ) > 0
            }}
      sequence:
        - if: "{{ input_verbose_logging_bool }}"
          then:
            - alias: "Update - Core - Logbook - Starting"
              continue_on_error: true
              action: logbook.log
              data:
                name: Auto-update
                entity_id: '{{ this.entity_id }}'
                message: "Starting sequence of core items updates..."
        - variables:
            pending_update_list: >
              {{ states.update
                | selectattr('state','eq','on')
                | selectattr('entity_id', 'in', pending_updates_list)
                | selectattr('entity_id', 'in', core_update_entity)
                | rejectattr('entity_id', 'in', os_update_entity)
                | rejectattr('entity_id', 'in', firmware_update_entities)
                | rejectattr('entity_id', 'in', input_update_exclusions)
                | map(attribute='entity_id')
                | list
                }}
        - if: "{{ input_verbose_logging_bool }}"
          then:
            - alias: "Update - Core - Logbook - Updating"
              continue_on_error: true
              action: logbook.log
              data:
                name: Auto-update
                entity_id: '{{ this.entity_id }}'
                message: "Updating {{pending_update_list[0]}} of {{pending_update_list}} ..."
        - alias: "Update - Core - Install"
          continue_on_error: true
          action: update.install
          data: {}
          target:
            entity_id: '{{ pending_update_list[0] }}'
        - alias: "Update - Core - Wait"
          continue_on_error: true
          wait_template: "{{ is_state(pending_update_list[0], 'off') }}"
          continue_on_timeout: true
          timeout: '3600'

  ########## Update OS ##########
  - *recalc_update_list
  - *logbook-variables
  - alias: "Update - OS"
    continue_on_error: true
    repeat:
      while:
        - "{{ input_core_os_update_mode in ['patches', 'major_and_minor', 'all'] }}"
        - condition: state
          entity_id: !input schedule_entity
          state: "on"
        - condition: template
          value_template: >
            {{ ( states.update
              | selectattr('state','eq','on')
              | selectattr('entity_id', 'in', pending_updates_list)
              | rejectattr('entity_id', 'in', core_update_entity)
              | selectattr('entity_id', 'in', os_update_entity)
              | rejectattr('entity_id', 'in', firmware_update_entities)
              | rejectattr('entity_id', 'in', input_update_exclusions)
              | map(attribute='entity_id')
              | list | count | int(0) ) > 0
            }}
      sequence:
        - if: "{{ input_verbose_logging_bool }}"
          then:
            - alias: "Update - OS - Logbook - Starting"
              continue_on_error: true
              action: logbook.log
              data:
                name: Auto-update
                entity_id: '{{ this.entity_id }}'
                message: "Starting sequence of OS update..."
        - variables:
            pending_update_list: >
              {{ states.update
                | selectattr('state','eq','on')
                | selectattr('entity_id', 'in', pending_updates_list)
                | rejectattr('entity_id', 'in', core_update_entity)
                | selectattr('entity_id', 'in', os_update_entity)
                | rejectattr('entity_id', 'in', firmware_update_entities)
                | rejectattr('entity_id', 'in', input_update_exclusions)
                | map(attribute='entity_id')
                | list
                }}
        - if: "{{ input_verbose_logging_bool }}"
          then:
            - alias: "Update - OS - Logbook - Updating"
              continue_on_error: true
              action: logbook.log
              data:
                name: Auto-update
                entity_id: '{{ this.entity_id }}'
                message: "Updating {{pending_update_list[0]}} of {{pending_update_list}} ..."
        - alias: "Update - OS - Install"
          continue_on_error: true
          action: update.install
          data: {}
          target:
            entity_id: '{{ pending_update_list[0] }}'
        - alias: "Update - OS - Wait"
          continue_on_error: true
          wait_template: "{{ is_state(pending_update_list[0], 'off') }}"
          continue_on_timeout: true
          timeout: '3600'

  ########## Devices firmware ##########
  - *recalc_update_list
  - alias: "Update - Devices firmware"
    continue_on_error: true
    repeat:
      while:
        - "{{ input_firmware_update_mode in ['patches', 'major_and_minor', 'all'] }}"
        - condition: state
          entity_id: !input schedule_entity
          state: "on"
        - condition: template
          value_template: >
            {{ ( states.update
              | selectattr('state','eq','on')
              | selectattr('entity_id', 'in', pending_updates_list)
              | rejectattr('entity_id', 'in', core_update_entity)
              | rejectattr('entity_id', 'in', os_update_entity)
              | selectattr('entity_id', 'in', firmware_update_entities)
              | rejectattr('entity_id', 'in', input_update_exclusions)
              | map(attribute='entity_id')
              | list | count | int(0) ) > 0
            }}
      sequence:
        - if: "{{ input_verbose_logging_bool }}"
          then:
            - alias: "Update - Devices firmware - Logbook - Starting"
              continue_on_error: true
              action: logbook.log
              data:
                name: Auto-update
                entity_id: '{{ this.entity_id }}'
                message: "Starting sequence of Devices firmware update..."
        - variables:
            pending_update_list: >
              {{ states.update
                | selectattr('state','eq','on')
                | selectattr('entity_id', 'in', pending_updates_list)
                | rejectattr('entity_id', 'in', core_update_entity)
                | rejectattr('entity_id', 'in', os_update_entity)
                | selectattr('entity_id', 'in', firmware_update_entities)
                | map(attribute='entity_id')
                | list
                }}
        - if: "{{ input_verbose_logging_bool }}"
          then:
            - alias: "Update - Devices firmware - Logbook - Updating"
              continue_on_error: true
              action: logbook.log
              data:
                name: Auto-update
                entity_id: '{{ this.entity_id }}'
                message: "Updating {{pending_update_list[0]}} of {{pending_update_list}} ..."
        - alias: "Update - Devices firmware - Install"
          continue_on_error: true
          action: update.install
          data: {}
          target:
            entity_id: '{{ pending_update_list[0] }}'
        - alias: "Update - Devices firmware - Wait"
          continue_on_error: true
          wait_template: "{{ is_state(pending_update_list[0], 'off') }}"
          continue_on_timeout: true
          timeout: '3600'

    ########## Finishing ##########
  - *recalc_update_list
  - *logbook-variables
  - if: "{{ input_verbose_logging_bool }}"
    then:
      - alias: "Logbook - Updating"
        continue_on_error: true
        action: logbook.log
        data:
          name: Auto-update
          entity_id: '{{ this.entity_id }}'
          message: Finishing update process.
      - alias: "Logbook - Remaining updates"
        continue_on_error: true
        action: logbook.log
        data:
          name: Auto-update
          entity_id: '{{ this.entity_id }}'
          message: >
            Remaining updates:
            - {{ states.update
              | selectattr('state','eq','on')
              | selectattr('entity_id', 'in', pending_updates_list)
              | rejectattr('entity_id', 'in', input_update_exclusions)
              | map(attribute='name') | list | join('

            - ') }}

  ########## Restart Home Assistant ##########
  - if: "{{ input_verbose_logging_bool }}"
    then:
      - alias: "Restart - Logbook"
        continue_on_error: true
        action: logbook.log
        data:
          name: Auto-update
          entity_id: '{{ this.entity_id }}'
          message: >
            {{ states.update
              | selectattr('attributes.release_summary', 'defined')
              | selectattr('attributes.release_summary', 'search', "<ha-alert alert-type='error'>")
              | map(attribute='entity_id')
              | list
              | count
              | int(0) }} item(s) pending a restart:
            - {{ states.update
              | selectattr('attributes.release_summary', 'defined')
              | selectattr('attributes.release_summary', 'search', "<ha-alert alert-type='error'>")
              | map(attribute='entity_id')
              | list
              | join('
            - ') }}
  - alias: "Restart"
    continue_on_error: true
    if:
      - >-
        {{ input_restart_type != "no-restart" and (
          (
            states.update
            | selectattr('attributes.release_summary', 'defined')
            | selectattr('attributes.release_summary', 'search', "<ha-alert alert-type='error'>")
            | map(attribute='entity_id')
            | list | count | int(0)
          ) > 0)
        }}
    then:
      - alias: "Restart - Check config"
        continue_on_error: true
        action: homeassistant.check_config
      - if:
          - "{{ states.persistent_notification.invalid_config.state | default('unavailable') == 'notifying' or states.persistent_notification.homeassistant_check_config.state | default('unavailable') == 'notifying' }}"
        then:
          - if: "{{ input_verbose_logging_bool }}"
            then:
              - alias: "Logbook: Running pre-restart actions"
                continue_on_error: true
                action: logbook.log
                data:
                  name: Auto-update
                  entity_id: '{{ this.entity_id }}'
                  message: Running pre-restart actions...
          - alias: "Run pre-restart actions"
            continue_on_error: true
            choose:
              - conditions:
                  - '{{ true }}'
                sequence: !input actions_pre_restart
            default: []
          - if: "{{ input_verbose_logging_bool }}"
            then:
              - alias: "Restart - Logbook - Skipping restart"
                continue_on_error: true
                action: logbook.log
                data:
                  name: Auto-update
                  entity_id: '{{ this.entity_id }}'
                  message: >
                    Skipping restart process due to notifications of invalid configurations:
                    states.persistent_notification.invalid_config.state = {{ states.persistent_notification.invalid_config.state | default('unavailable') }},
                    states.persistent_notification.homeassistant_check_config.state = {{ states.persistent_notification.homeassistant_check_config.state | default('unavailable') }}
        else:
          - alias: "Restart - Logbook - Restarting"
            continue_on_error: true
            action: logbook.log
            data:
              name: Auto-update
              entity_id: '{{ this.entity_id }}'
              message: 'Restarting Home Assistant {{ input_restart_type }}...'
          - alias: "Restart - Call reboot service"
            continue_on_error: true
            action: '{{ "hassio.host_reboot" if input_restart_type == "host" else "homeassistant.restart" }}'

    ########## Post-update actions ##########
  - if: "{{ input_verbose_logging_bool }}"
    then:
      - alias: "Logbook - Post-actions"
        continue_on_error: true
        action: logbook.log
        data:
          name: Auto-update
          entity_id: '{{ this.entity_id }}'
          message: Running post-update actions...

  - alias: "Run post-update actions"
    continue_on_error: true
    choose:
      - conditions:
          - '{{ true }}'
        sequence: !input actions_pos_update
    default: []

    ########## Done! ##########
  - if: "{{ input_verbose_logging_bool }}"
    then:
      - alias: "Logbook - Done"
        continue_on_error: true
        action: logbook.log
        data:
          name: Auto-update
          entity_id: '{{ this.entity_id }}'
          message: Done!
